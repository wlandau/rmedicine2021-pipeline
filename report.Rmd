---
title: "# Target Markdown and stantargets for Bayesian model validation pipelines"
author: "Will Landau"
output:
  html_document:
    toc: true
    number_sections: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

The `targets` R package enhances the reproducibility, scale, and maintainability of data science projects in computationally intense fields such as machine learning, Bayesian Statistics, and statistical genomics. Recent breakthroughs in the targets ecosystem make it easy to create ambitious, domain-specific, reproducible data analysis pipelines. Two highlights include Target Markdown, an R Markdown interface to transparently communicate the entire process of pipeline construction and prototyping, and `stantargets`, a new rOpenSci package that generates specialized workflows for Stan models while reducing the required volume of user-side R code.

# Methods

This Target Markdown report demonstrates both capabilities in an exercise to validate a mixed model of repeated measures (MMRM), one of the most ubiquitous longitudinal models in clinical trials. Using multiple simulated datasets from the prior predictive distribution of the model, we evaluate how well the model recovers the true parameters drawn from the data-generating process.
 
## MMRM model

We use a mixed model of repeated measures (MMRM) for clinical trial data. The model assumes independent patients, correlated study visits within each patient, and an LKJ prior on the correlation matrix for study visits. MMRM models with unstructured covariance usually apply the inverse Wishart prior, but this prior induces known biases that could be problematic (<https://arxiv.org/abs/1408.4050>), which motivated this custom Stan model that uses LKJ instead. 

### Notation

* $n$: number of patients.
* $t$: number of scheduled study visits for a given patient.
* $p$: number of model coefficients in the parameter vector $\beta$.
* $y$: vector of length $n \cdot t$ with observed responses for the clinical endpoint.
* $X_{(n \cdot t) \times p}$: model matrix with $n \cdot t$ rows and $p$ columns.
* $I_{x \times x}$: the identity matrix with $x$ rows and $x$ columns.
* $\otimes$: Kronecker product.
* $\Sigma_{t \times t}$: $t \times t$ block of the covariance matrix of the observed data.
* $\sigma$: vector of length $t$ with standard deviations $\sigma_1, \ldots, \sigma_t$ of the clinical endpoint at each study visit.
* $\Lambda_{t \times t}$: Cholesky factor of the $t \times t$ block of the correlation matrix of the observed data.

### Specification

$$
\begin{aligned}
& y \sim \text{MVN}(X_{(n \cdot t) \times p} \beta, \ I_{n \times n} \otimes \Sigma_{t \times t} ) \\
& \qquad \beta \sim \text{MVN} (0, 10^2 I_{p \times p})\\
&  \qquad \Sigma_{t \times t} = \left (I_{t \times t} \sigma \right ) \Lambda_{t \times t} \Lambda_{t \times t}' \left (I_{t \times t} \sigma \right ) \\
& \qquad \qquad \sigma_1, \ldots, \sigma_t \stackrel{\text{ind}}{\sim} \text{Cauchy}^+(0, 5) \\
& \qquad \qquad \Lambda_{t \times t}\Lambda_{t \times t}' \sim \text{LKJ}(\eta = 1, K = t)
\end{aligned}
$$

### Stan code

```{r}
writeLines(readLines("model.stan"))
```

## Interval-based validation

The goal of this validation exercise is to verify that the fitted model recovers the parameter values used to generate the original data. This serves as evidence that the Stan code was implemented correctly. Steps:

* For independent replication $i = 1, ..., 1000$:
  1. Draw a set of "true" parameters parameters from the joint prior.
  2. Draw a dataset from the likelihood given the parameter draws from (1).
  3. Fit the Stan model to the data.
  4. For each parameter (index $p$) let $c_{ip}$ = 1 if the $100(1 - \alpha)$% posterior interval covers the prior predictive draw from (1). Otherwise, $c_{ip}$ = 0.
* For each parameter $p$, calculate coverage: $C_p = \frac{1}{n} \sum_{i = i}^n c_{ip}$. If $C_p$ is systematically different from $1 - \alpha$, then there are problems with the model or the software.

Simulation-based calibration (SBC) is a similar technique. SBC may be more robust than the interval-based validation technique above, but the latter is easier to perform with `stantargets` and easier to communicate for high-dimensional models. (Parameter-specific rank statistic histograms can be difficult to inspect when there are many parameters.)

# Pipeline

## Setup

First, we load the `targets` package to register the Target Markdown `knitr` language engine.

```{r}
library(targets)
```

Next, we remove transient scripts previously generated by Target Markdown in non-interactive mode (optional).

```{r}
tar_unscript()
```

In our first Target Markdown code chunk, we declare global settings to register packages and high-performance computing settings.

```{targets settings, tar_globals = TRUE}
tar_option_set(
  packages = c("tidyverse", "trialr"),
  storage = "remote",
  retrieval = "remote"
)
options(clustermq.scheduler = "sge", clustermq.template = "sge.tmpl")
```

## Data generation

The following function simulates one rep of a clinical trial data from the prior predictive distribution of an MMRM model. The function returns a Stan data list and accepts arguments `n_patients` (number of patients in the trial), `n_visits` (number of scheduled study visits, e.g. repeated measures per patient), and `n_arms` (number of study arms, e.g. treatment groups). The model coefficients `beta` come from independent `Normal(0, sd = 10)` distributions, and the covariance matrix comes from an `LKJ(shape = 1, order = n_visits)` distribution. To mitigate numerical stability issues, the covariance matrix is restricted such that each matrix element lies between -500 and 500 (via rejection sampling). The `.join_data` list at the end tells `stantargets` to append the prior predictive draws of model parameters to the MCMC output.

```{targets data, tar_globals = TRUE}
simulate_data <- function(n_patients = 500, n_visits = 4, n_arms = 2) {
  structure <- tibble(patient = as.character(seq_len(n_patients))) %>%
    mutate(arm = as.character(rep(seq_len(n_arms), each = n_patients / n_arms))) %>%
    mutate(covariate1 = rnorm(n()), covariate2 = rnorm(n())) %>%
    expand_grid(visit = as.character(seq_len(n_visits))) %>%
    mutate(group = paste0(arm, visit))
  x <- model.matrix(~ covariate1 + covariate2 + group, data = structure) %>%
    as.matrix()
  beta <- rnorm(ncol(x), 10)
  covariance <- NULL
  while (is.null(covariance) || max(abs(covariance)) > 100) {
    rho <- rlkjcorr(n = 1, K = n_visits, eta = 1)
    sigma <- rcauchy(n = n_visits, location = 0, scale = 1)
    covariance <- diag(sigma) %*% rho %*% diag(sigma)
  }
  data <- structure %>%
    mutate(x_beta = as.numeric(x %*% beta)) %>%
    group_by(patient) %>%
    mutate(response = MASS::mvrnorm(n = 1L, mu = x_beta, Sigma = covariance)) %>%
    ungroup() %>%
    select(response, arm, patient, visit, covariate1, covariate2, group)
  list(
    data = data,
    y = data$response,
    x = x,
    n_arms = n_arms,
    n_beta = length(beta),
    n_observations = n_patients * n_visits,
    n_patients = n_patients,
    n_visits = n_visits,
    s_beta = 10,
    s_sigma = 5,
    .join_data = list(
      beta = beta,
      sigma = sigma,
      rho = rho
    )
  )
}
```
